\chapter{Практика}
\label{ch:chap2}

В данной главе рассматриваются ключевые аспекты реализации GPS Loacation на языке Kotlin с использованием Jetpack Compose. 
Основное листингу проекта.

\section{Среда разработки}

Для реализации проекта использовалась следующая среда:

\begin{itemize}
    \item \textbf{Язык программирования}: Kotlin
    \item \textbf{Среда разработки (IDE)}: Android Studio
    \item \textbf{Минимальная версия SDK}: 21 (Android 5.0 Lollipop)
    \item \textbf{Целевая версия SDK}: 33 (Android 13)
    \item \textbf{Библиотеки и технологии:}
    \begin{itemize}
        \item Jetpack Compose (UI)
        \item FusedLocationProviderClient (Google Play Services)
        \item LocationManager (проверка статуса GPS/сети)
        \item MediaStore и File API (сохранение данных)
    \end{itemize}
\end{itemize}

\section{MapPage.kt}

Приложение состоит из следующих ключевых компонентов:

\begin{itemize}
    \item \textbf{MapPage.kt} — Основная активность, в которой инициализируется Compose-интерфейс.
    \item \textbf{LocationScreen() (Compose-функция)} — Реализует UI: отображение координат, кнопка возврата.
    \item \textbf{Взаимодействие с локацией:} — FusedLocationProviderClient для получения последней известной локации. LocationManager для проверки активности GPS/сети.
\end{itemize}

Состояния и данные:

\begin{itemize}
    \item \textbf{Текущие координаты} — широта и долгота (обновляются через mutableStateOf).
    \item \textbf{Статус разрешений} — \texttt{ACCESS\_FINE\_LOCATION} (обрабатывается через \texttt{ActivityResultLauncher}).
    \item \textbf{Статус геолокации} — проверка включения GPS/сети.
\end{itemize}

\begin{lstlisting}[language=Kotlin, caption=MapPage.kt]

package com.example.mycal.activities

import android.Manifest
import android.content.ContentValues
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.location.LocationManager
import android.os.Bundle
import android.os.Environment
import android.provider.MediaStore
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import com.example.mycal.MainPage
import com.example.mycal.ui.theme.MycalTheme
import com.example.mycal.ui.theme.Rose
import com.example.mycal.ui.theme.Russian_Violete
import com.google.android.gms.location.LocationServices
import org.json.JSONObject

class LocationActivity : ComponentActivity() {

    @OptIn(ExperimentalMaterial3Api::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        setContent {
            MycalTheme {
                Surface(modifier = Modifier.fillMaxSize(), color = Russian_Violete) {
                    LocationScreen()
                }
            }
        }
    }

    @Composable
    fun LocationScreen() {
        val context = LocalContext.current

        var latText by remember { mutableStateOf("—") }
        var lonText by remember { mutableStateOf("—") }
        var hasPermission by remember { mutableStateOf(false) }

        val permissionLauncher = rememberLauncherForActivityResult(
            contract = ActivityResultContracts.RequestPermission()
        ) { granted ->
            hasPermission = granted
            if (!granted) {
                Toast.makeText(
                    context,
                    "Без разрешения получение локации невозможно",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }

        LaunchedEffect(Unit) {
            permissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)
        }

        LaunchedEffect(hasPermission) {
            if (hasPermission) {
                val lm = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager
                val enabled = lm.isProviderEnabled(LocationManager.GPS_PROVIDER)
                        || lm.isProviderEnabled(LocationManager.NETWORK_PROVIDER)
                if (!enabled) {
                    Toast.makeText(
                        context,
                        "Включите геолокацию в настройках, пожалуйста",
                        Toast.LENGTH_LONG
                    ).show()
                } else {
                    val permissionGranted = ContextCompat.checkSelfPermission(
                        context,
                        Manifest.permission.ACCESS_FINE_LOCATION
                    ) == PackageManager.PERMISSION_GRANTED

                    if (permissionGranted) {
                        val client = LocationServices.getFusedLocationProviderClient(context)
                        client.lastLocation
                            .addOnSuccessListener { location ->
                                if (location != null) {
                                    latText = location.latitude.toString()
                                    lonText = location.longitude.toString()
                                    saveCoordsToDownloads(context, location.latitude, location.longitude)
                                } else {
                                    Toast.makeText(
                                        context,
                                        "Не удалось получить локацию",
                                        Toast.LENGTH_SHORT
                                    ).show()
                                }
                            }
                            .addOnFailureListener {
                                Toast.makeText(
                                    context,
                                    "Ошибка при получении локации",
                                    Toast.LENGTH_SHORT
                                ).show()
                            }
                    } else {
                        Toast.makeText(
                            context,
                            "Разрешение на геолокацию не получено",
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                }
            }
        }

        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            verticalArrangement = Arrangement.SpaceBetween,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    "Текущие координаты",
                    style = MaterialTheme.typography.headlineMedium,
                    color = Color.White
                )
                Spacer(Modifier.height(16.dp))
                Text("Широта: $latText", style = MaterialTheme.typography.bodyLarge, color = Color.White)
                Text("Долгота: $lonText", style = MaterialTheme.typography.bodyLarge, color = Color.White)
            }

            Button(
                onClick = {
                    context.startActivity(Intent(context, MainPage::class.java))
                },
                colors = ButtonDefaults.buttonColors(Rose),
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp)
            ) {
                Text("Back to Main", color = Color.White)
            }
        }
    }

    private fun saveCoordsToDownloads(context: Context, lat: Double, lon: Double) {
        val json = JSONObject().apply {
            put("latitude", lat)
            put("longitude", lon)
            put("timestamp", System.currentTimeMillis())
        }
        val filename = "coords_${System.currentTimeMillis()}.json"
        val bytes = json.toString(2).toByteArray()

        val values = ContentValues().apply {
            put(MediaStore.Downloads.DISPLAY_NAME, filename)
            put(MediaStore.Downloads.MIME_TYPE, "application/json")
            put(MediaStore.Downloads.RELATIVE_PATH, Environment.DIRECTORY_DOWNLOADS)
        }
        val uri = context.contentResolver.insert(
            MediaStore.Downloads.EXTERNAL_CONTENT_URI, values
        )
        if (uri != null) {
            context.contentResolver.openOutputStream(uri).use { it?.write(bytes) }
            Toast.makeText(
                context,
                "Координаты сохранены в Downloads/$filename",
                Toast.LENGTH_LONG
            ).show()
        } else {
            Toast.makeText(context, "Не удалось создать файл в Downloads", Toast.LENGTH_SHORT).show()
        }
    }
}

\end{lstlisting}

Интерфейс реализован с помощью Jetpack Compose. В нём отображаются:

\begin{itemize}
    \item \textbf{Основной контент}
        \begin{itemize}
            \item Заголовок "Текущие координаты" (белый цвет, крупный шрифт)
            \item Поле "Широта: —" (белый цвет)
            \item Поле "Долгота: —" (белый цвет)
        \end{itemize}
    \item \textbf{Кнопка внизу экрана}
        \begin{itemize}
            \item Текст "Back to Main" (белый цвет)
            \item Розовый фон (цвет Rose)
            \item Занимает всю ширину экрана
            \item Высота 56dp
        \end{itemize}
\end{itemize}

Общий принцип работы:

\begin{itemize}
    \item  \textbf{Инициализация и запрос разрешений:}
        \begin{itemize}
            \item При старте активити автоматически запускается запрос разрешения \texttt{ACCESS\_FINE\_LOCATION}
            \item Используется ActivityResultLauncher для обработки ответа пользователя
            \item Состояние hasPermission отслеживает наличие/отсутствие разрешения
        \end{itemize}
    \item \textbf{Проверка доступности геолокации:}
        \begin{itemize}
            \item После получения разрешения проверяется статус GPS/сетевых провайдеров
            \item Если геолокация отключена - показывается Toast с просьбой включить
            \item При успешной проверке переходит к получению координат
        \end{itemize}
    \item \textbf{Получение местоположения:}
        \begin{itemize}
            \item Используется FusedLocationProviderClient для доступа к API локации
            \item Запрашивается последнее известное местоположение (lastLocation)
            \item Реализованы коллбеки:
            \begin{itemize}
                \item onSuccessListener - обработка успешного получения координат
                \item onFailureListener - обработка ошибок получения
            \end{itemize}
        \end{itemize}
    \item \textbf{Обновление UI и сохранение данных:}
        \begin{itemize}
            \item Полученные координаты обновляют состояние latText/lonText
            \item Вызывается saveCoordsToDownloads() для сохранения в файл:
            \begin{itemize}
                \item Создается JSON-объект с координатами и временной меткой
                \item Используется MediaStore API для сохранения в папку Downloads
                \item Имя файла генерируется по шаблону \texttt{coords\_<timestamp>.json}
            \end{itemize}
        \end{itemize}
    \item \textbf{Обратная связь с пользователем:}
        \begin{itemize}
            \item Toast-уведомления о статусе операций
            \item Визуальное отображение координат в реальном времени
            \item Обработка ошибок (отсутствие разрешения, проблемы с записью файла)
        \end{itemize}
    \item \textbf{Навигация:}
        \begin{itemize}
            \item Кнопка "Back to Main" запускает MainPage через явный Intent
            \item Сохранение данных происходит асинхронно, не блокируя UI
        \end{itemize}
    \item \textbf{Ключевые технологии:}
        \begin{itemize}
            \item Jetpack Compose для UI
            \item Location Services API (Fused Location Provider)
            \item Система разрешений Android (Runtime Permissions)
            \item ContentResolver для работы с MediaStore
            \item JSON для сериализации данных
            \item Асинхронная обработка через Listeners
        \end{itemize}
    \item \textbf{Поток данных:}
        \begin{itemize}
            \item Запрос разрешения → Проверка GPS → Получение локации → Обновление UI → Сохранение в файл → Возможность возврата на главный экран
        \end{itemize}
\end{itemize}

Особенность: Все операции с геолокацией и файловой системой выполняются асинхронно, что предотвращает блокировку основного потока UI.
